--[[
	Copyright HaruCoded (c) 2023

	This file cannot be directly imported and require pre processing with the
	'h3d_format' file
]]
local raster = {}

-- Globals
{%
for _, name in pairs(LAYERS) do
	@insert('local layer_' .. name .. ' = {}\n')
	@insert('local layer_' .. name .. '_write = 0\n')
end
%}

local layers = {
{%
for _, name in pairs(LAYERS) do
	@insert('\t' .. name .. ' = layer_' .. name .. ',\n')
end
%}
}

local TRIANGLES = 0
local H = 1
local W = 1
local TEXTURE = nil
local MISSING_TEXTURE = {
	w = 8,
	h = 8,
	data = {
		0, 185, 0, 185, 0, 185, 0, 185,
		185, 0, 185, 0, 185, 0, 185, 0,
		0, 185, 0, 185, 0, 185, 0, 185,
		185, 0, 185, 0, 185, 0, 185, 0,
		0, 185, 0, 185, 0, 185, 0, 185,
		185, 0, 185, 0, 185, 0, 185, 0,
		0, 185, 0, 185, 0, 185, 0, 185,
		185, 0, 185, 0, 185, 0, 185, 0,
	}
}

{%
-- Should be env variables
local USE_FACE_CULL  = false

-- Calculated
local function get_attribute_name_raw(attribute)
	return '_' .. attribute.name .. '_'
end
local function get_attribute_name(attribute, index)
	if attribute.count == 1 then
		return '_' .. attribute.name
	end
	return get_attribute_name_raw(attribute) .. ("xyzw"):sub(index, index)
end

local pos_attr = get_attribute_name_raw(POSITION_ATTRIBUTE)


local function get_lines(lines)
	local result = {}
	for i=1,#lines do
		local line = lines[i]
		if type(line) == 'table' then
			if line[2] then
				result[#result + 1] = line[1]
			end
		else
			result[#result + 1] = line
		end
	end

	return table.concat(result, '\n')
end

local function textindent(text, tabs)
	local lines = {}
	for s in string.gmatch(text .. "\n", "(.-)\n") do
		table.insert(lines, s)
	end
	local pad = ''
	for i=1,tabs do
		pad = pad .. '\t'
	end
	return pad .. table.concat(lines, '\n' .. pad):gsub('\n[\t]+\n', '\n\n')
end

local function if_greater(variables, gt, callback, indent)
	indent = indent or 1
	local function internal(state, index)
		if index <= #variables then
			state[index] = true
			local a = internal(state, index + 1)
			state[index] = false
			local b = internal(state, index + 1)
			if a ~= '' then
				local result = 'if ' .. variables[index] .. ' > ' .. gt .. ' then\n' .. textindent(a, indent)
				if b ~= '' then
					result = result .. '\nelse\n' .. textindent(b, indent)
				end
				return result .. '\nend'
			elseif b ~= '' then
				return 'if ' .. variables[index] .. ' <= ' .. gt .. ' then\n' .. textindent(b, indent) .. '\nend'
			end
			return ''
		else
			return callback(state)
		end
	end
	local state = {}
	for i = 1, #variables do
		state[i] = false
	end
	return internal(state, 1)
end

local function if_sorted(variables, callback, indent)
	indent = indent or 1
	local function permgen(a, n, states)
		if n == 0 then
			local clone = {}
			for i,v in pairs(a) do
				clone[i] = v
			end
			states[#states + 1] = clone
		else
			for i = 1, n, 1 do
				a[n], a[i] = a[i], a[n]
				permgen(a, n - 1, states)
				a[n], a[i] = a[i], a[n]
			end
		end
	end
	local function internal(matrix, perms)
		if #perms == 0 then
			return ''
		elseif #perms == 1 then
			local state = {}
			for i, v in pairs(perms[1]) do
				state[v] = i
			end
			return callback(state)
		end

		-- Get option with most items
		local a_elm = matrix[1]
		local a_idx = 1
		for i=2,#variables do
			local match = matrix[i]
			if a_elm.count < match.count then
				a_elm = match
				a_idx = i
			end
		end

		local b_idx = nil
		for i=1,#variables do
			if a_elm[i] then
				b_idx = i
				break
			end
		end

		local s_t = {}
		local s_f = {}
		for _, v in pairs(perms) do
			if v[a_idx] < v[b_idx] then
				s_t[#s_t + 1] = v
			else
				s_f[#s_f + 1] = v
			end
		end

		matrix[a_idx][b_idx] = nil
		matrix[a_idx].count = matrix[a_idx].count - 1

		local a = internal(matrix, s_t)
		local b = internal(matrix, s_f)

		matrix[a_idx][b_idx] = true
		matrix[a_idx].count = matrix[a_idx].count + 1

		if a ~= '' then
			if b ~= '' then
				return 'if ' .. variables[a_idx] .. ' >= ' .. variables[b_idx] .. ' then\n' .. textindent(a, indent) .. '\nelse\n' .. textindent(b, indent) .. '\nend' 
			end
			return a
		elseif b ~= '' then
			return b
		end

		return ''
	end

	local matrix = {}
	local a = {}
	for i=1,#variables do
		matrix[i] = {}
		matrix[i].count = #variables - i
		a[i] = i
		for j=i+1,#variables do
			matrix[i][j] = true
		end
	end

	local states = {}
	permgen(a, #variables, states)

	local perms = {}
	for i=1,#states do
		perms[i] = {}
		for j,v in pairs(states[i]) do
			perms[i][v] = j
		end
	end 

	return internal(matrix, perms)
end

-- TODO: Find how to split the trinagles in such a case we always have them sorted
local function triangleCases(state)
	local function delta(t, use_a, use_b, use_c)
		local pattern = '({t}{1} - {t}{{v}}) * m{1}{{v}} + {t}{{v}}'
		local result =
			(use_a ~= nil and pattern:gsub('{v}', use_a) or '{t}{1}') .. ', ' ..
			(use_b ~= nil and pattern:gsub('{v}', use_b) or '{t}{2}') .. ', ' ..
			(use_c ~= nil and pattern:gsub('{v}', use_c) or '{t}{3}')
		return result:gsub('{t}', t)
	end

	local function delta_z(t, use_a, use_b, use_c)
		local result =
			(use_a ~= nil and 'near' or '{t}{1}') .. ', ' ..
			(use_b ~= nil and 'near' or '{t}{2}') .. ', ' ..
			(use_c ~= nil and 'near' or '{t}{3}')
		return result:gsub('{t}', t)
	end

	local function get_variables(a, b, c)
		local lines = {}
		for _,v in pairs(VERTEX_ATTRIBUTES) do
			lines[#lines + 1] = '-- ' .. v.name
			if v.position then
				for index=1,v.count do
					local element = get_attribute_name(v, index)

					if index == 3 then
						lines[#lines + 1] = ', ' .. delta_z(element, a, b, c)
					else
						lines[#lines + 1] = ', ' .. delta(element, a, b, c)
					end
				end
			else
				for index=1,v.count do
					local element = get_attribute_name(v, index)
					lines[#lines + 1] = ', ' .. delta(element, a, b, c)
				end
			end
		end
		for _,v in pairs(FACE_ATTRIBUTES) do
			lines[#lines + 1] = '-- ' .. v.name
			for index=1,v.count do
				local element = get_attribute_name(v, index)
				lines[#lines + 1] = ', ' .. element
			end
		end

		return get_lines(lines):gsub('^(.-),( .*)', '%1 %2')
	end

	local inside = 0
	local i_idx = 0
	local o_idx = 0
	local desc = ''
	for i, v in ipairs(state) do
		if i > 1 then
			desc = desc .. ' '
		end
		desc = desc .. (v and i or '.')
		inside = inside + (v and 1 or 0)
		if v then
			i_idx = i
		else
			o_idx = i
		end
	end

	if inside == 0 then
		return ''
	end

	local s_idx = 1
	local out = ''
	if inside == 1 then
		out = get_lines({
			'-- ' .. desc,
			'local m{1}{2} = (near - {p}z{2}) / ({p}z{1} - {p}z{2})',
			'local m{1}{3} = (near - {p}z{3}) / ({p}z{1} - {p}z{3})',
			'renderTriangle(', textindent(get_variables(nil, 2, 3), 1), ')'
		})
		s_idx = i_idx
	elseif inside == 2 then
		out = get_lines({
			'-- ' .. desc,
			'local m{1}{2} = (near - {p}z{2}) / ({p}z{1} - {p}z{2})',
			'local m{1}{3} = (near - {p}z{3}) / ({p}z{1} - {p}z{3})',
			'renderTriangle(', textindent(get_variables(2, nil, nil), 1), ')',
			'renderTriangle(', textindent(get_variables(3, 2, nil), 1), ')'
		})
		s_idx = o_idx
	else
		out = get_lines({
			'-- ' .. desc,
			'renderTriangle(', textindent(get_variables(nil, nil, nil), 1), ')'
		})
	end

	return out:gsub('{1}', tostring(s_idx))
			  :gsub('{2}', tostring(1 + (s_idx + 0) % 3))
			  :gsub('{3}', tostring(1 + (s_idx + 1) % 3))
			  :gsub('{p}', pos_attr)
end

local function get_parameters_sort()
	local lines = {}
	for _,v in pairs(VERTEX_ATTRIBUTES) do
		lines[#lines + 1] = '-- ' .. v.name
		for index=1,v.count do
			local element = get_attribute_name(v, index)
			lines[#lines + 1] = ', ' .. element .. '{1}, ' .. element .. '{2}, ' .. element .. '{3}'
		end
	end
	for _,v in pairs(FACE_ATTRIBUTES) do
		lines[#lines + 1] = '-- ' .. v.name
		for index=1,v.count do
			local element = get_attribute_name(v, index)
			lines[#lines + 1] = ', ' .. element
		end
	end
	return table.concat(lines, '\n'):gsub('^(.-),( .*)', '%1 %2')
end

local function get_parameters()
	return get_parameters_sort()
		:gsub('{1}', '1')
		:gsub('{2}', '2')
		:gsub('{3}', '3')
end
%}

local _math_clamp = function(x, min, max)
	if x < min then return min end
	if x > max then return max end
	return x
end

local function renderTriangleInternal(
	y_min, y_mid, y_max,
	x_min, x_mid, x_max,
	x_sta, x_end,

{! textindent(get_parameters(), 1) !}
)
	local _math_floor = math.floor
	local _math_ceil  = math.ceil
	local _math_max   = math.max
	local _math_min   = math.min

{#full_function#}
	TRIANGLES = TRIANGLES + 1
{%
	-- Apply perspective correction on vertex attributes
	if POSITION_ATTRIBUTE.count > 2 and #VERTEX_ATTRIBUTES > 1 then
		for i=1,3 do
			@insert('\t' .. pos_attr .. 'z' .. i .. ' = 1 / ' .. pos_attr .. 'z' .. i .. '\n')
		end

		for _, v in pairs(VERTEX_ATTRIBUTES) do
			if not v.position then
				@insert('\t-- ' .. v.name .. '\n')
				for i=1,3 do
					for index=1,v.count do
						local element = get_attribute_name(v, index)
						@insert('\t' .. element .. i .. ' = ' .. element .. i .. ' * ' .. pos_attr .. 'z' .. i .. '\n')
					end
				end
			end
			@insert('\n')
		end
	end
%}
{% if SHADER.uses_barycentric then %}
	-- Barycentric calculations
	local cyx = x_max - x_min
	local cyy = y_max - y_min
	local czx = x_mid - x_min
	local czy = y_mid - y_min
	local det = 1 / (czx * cyy - cyx * czy)
{% end%}

	local tex = TEXTURE or MISSING_TEXTURE
	local tw = tex.w
	local th = tex.h
	local td = tex.data

	local y_d0 = y_mid - y_max
	local y_d1 = y_min - y_mid

	-- y_d0 = y_mid - y_max
	if y_d0 > 0 then -- TOP TRIANGLE, FLAT BOTTOM
		local x13_s = (x_sta - x_max) / y_d0
		local x23_s = (x_end - x_max) / y_d0
		local dy0 = _math_ceil(y_max - 0.5)
		local dy1 = dy0 + (0.5 - y_max)

		y_d0     = _math_min(y_d0 - dy1, H - dy0)
		local ys = _math_max(0         , 1 - dy0)
		for yy=ys,y_d0 do
			local xs = (yy + dy1) * x13_s + x_max
			local xe = (yy + dy1) * x23_s + x_max
			local yb = yy + dy0

{#triangle#}
{%
			for name, _ in pairs(SHADER.used_layers) do
				@insert('\t\t\tlocal layer_' .. name .. '_y = layer_' .. name .. '[yb]\n')
			end
%}
{% if SHADER.uses_barycentric then %}
			local yyy = yb - y_min + 0.5
{% end %}
			xs = _math_max(xs, 1)
			xe = _math_min(xe, W)
			xs = _math_ceil(xs - 0.5)
			xe = _math_ceil(xe - 0.5) - 1
			for xx=xs,xe do
{! textindent(FRAG_SHADER, 4) !}
			end
{#triangle#}
		end
	end

	-- y_d1 = y_min - y_mid
	if y_d1 > 0 then -- BOTTOM TRIANGLE, FLAT TOP
		local x13_s = (x_min - x_sta) / y_d1
		local x23_s = (x_min - x_end) / y_d1
		local dy0 = _math_ceil(y_mid - 0.5)
		local dy1 = dy0 + (0.5 - y_mid)

		y_d1     = _math_min(y_d1 - dy1, H - dy0)
		local ys = _math_max(0         , 1 - dy0)
		for yy=ys,y_d1 do
			local xs = (yy + dy1) * x13_s + x_sta
			local xe = (yy + dy1) * x23_s + x_end
			local yb = yy + dy0

{#triangle#}
		end
	end
{#full_function#}
end

local function renderTriangle(
{! textindent(get_parameters(), 1) !}
)
	local A = W / 2.0
	local B = H / 2.0
	local sx1 = A + ({!pos_attr!}x1 * H) / {!pos_attr!}z1
	local sx2 = A + ({!pos_attr!}x2 * H) / {!pos_attr!}z2
	local sx3 = A + ({!pos_attr!}x3 * H) / {!pos_attr!}z3
	local sy1 = B + ({!pos_attr!}y1 * H) / {!pos_attr!}z1
	local sy2 = B + ({!pos_attr!}y2 * H) / {!pos_attr!}z2
	local sy3 = B + ({!pos_attr!}y3 * H) / {!pos_attr!}z3
{% if USE_FACE_CULL then %}
	if ((sx2 - sx1) * (sy3 - sy1) - (sx3 - sx1) * (sy2 - sy1)) < 0 then
		return
	end
{% end %}

{!
textindent(if_sorted({ 'sy1', 'sy2', 'sy3' }, function(state)
	local res = ''
	for i,v in pairs(state) do
		if i > 1 then
			res = res .. ','
		end
		res = res .. v
	end

	local out = get_lines({
		'local x_sta = ((sx{1} - sx{3}) / (sy{1} - sy{3})) * (sy{2} - sy{1}) + sx{1}',
		'local x_end = sx{2}',
		'if x_sta > x_end then',
		'	x_sta, x_end = x_end, x_sta',
		'end',
		--[[textindent(
			{#full_function#}
				:gsub('y_min', 'sy{1}')
				:gsub('y_mid', 'sy{2}')
				:gsub('y_max', 'sy{3}')

				:gsub('x_min', 'sx{1}')
				:gsub('x_mid', 'sx{2}')
				:gsub('x_max', 'sx{3}')

				-- TODO do for all vertex attributes
		, 0),]]
		'renderTriangleInternal(',
		'	sy{1}, sy{2}, sy{3},',
		'	sx{1}, sx{2}, sx{3},',
		'	x_sta, x_end,',
			textindent(get_parameters_sort(), 1),
		')'
	})

	out = out:gsub('{1}', tostring(state[1]))
			 :gsub('{2}', tostring(state[2]))
			 :gsub('{3}', tostring(state[3]))
	return '-- {' .. res .. '}\n' .. out
end), 1)
!}
end

function raster.drawGeometry(geometry, near)
{%
	local face_size = 0
	for _, v in pairs(VERTEX_ATTRIBUTES) do
		face_size = face_size + v.count * 3
	end
	for _, v in pairs(FACE_ATTRIBUTES) do
		face_size = face_size + v.count
	end
%}
	for i=1,#geometry,{!face_size!} do
{%
		local idx = 0
		for _, v in pairs(VERTEX_ATTRIBUTES) do
			@insert('\t\t-- ' .. v.name .. '\n')
			for i=1,3 do
				for index=1,v.count do
					local element = get_attribute_name(v, index)
					local pattern = '\t\tlocal {t}{1} = geometry[i + ' .. (idx) .. ']\n'
					@insert(pattern:gsub('{t}', element):gsub('{1}', i))
					idx = idx + 1
				end
			end
			@insert('\n')
		end

		for _, v in pairs(FACE_ATTRIBUTES) do
			@insert('\t\t-- ' .. v.name .. '\n')
			for index=1,v.count do
				local element = get_attribute_name(v, index)
				@insert('\t\tlocal ' .. element .. ' = geometry[i + ' .. idx .. ']' .. '\n')
				idx = idx + 1
			end
			@insert('\n')
		end
%}
{!
		textindent(if_greater({ pos_attr .. 'z1', pos_attr .. 'z2', pos_attr .. 'z3' }, 'near', triangleCases), 2)
!}
	end
end

function raster.set_layer(name, value)
	local layer = layers[name]
	if layer == nil then
		return
	end

	for y=1,H do
		local row = layer[y]
		for x=1,W do
			row[x] = value
		end
	end
end

function raster.get_layer(name)
	return layers[name]
end

function raster.set_size(w, h)
	W = w
	H = h

	-- Resize 
	for y=1,h do
{%
		for _, name in pairs(LAYERS) do
			@insert('\t\tlayer_' .. name .. '[y] = {}\n')
		end
%}
		for x=1,w do
{%
			for _, name in pairs(LAYERS) do
				@insert('\t\t\tlayer_' .. name .. '[y][x] = 0\n')
			end
%}
		end
	end
end

function raster.set_texture(texture)
	TEXTURE = texture
end

function raster.get_rastered_info()
	local result = {
		fragment = {
{%
			for _, name in pairs(LAYERS) do
				@insert('\t\t\t' .. name .. ' = layer_' .. name .. '_write,\n')
			end
%}
		},
		triangles = TRIANGLES
	}

	TRIANGLES = 0
{%
	for _, name in pairs(LAYERS) do
		@insert('\tlayer_' .. name .. '_write = 0\n')
	end
%}

	return result
end

return raster
