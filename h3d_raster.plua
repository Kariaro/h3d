--[[
	Copyright HaruCoded (c) 2023

	This file cannot be directly imported and require pre processing with the
	'h3d_format' file
]]
local raster = {}

-- Globals
local PIXELS = {}
local DEPTHS = {}
local RASTERED = 0
local TRIANGLES = 0
local TEXTURE = nil
local H = 1
local W = 1
local C = 1

raster.PIXELS = PIXELS
raster.DEPTHS = DEPTHS


{%
-- Should be env variables
local USE_COLOR      = false
local USE_DEPTH      = false
local USE_UV         = false
local USE_FACE_CULL  = false

-- Calculated
local function get_attribute_name_raw(attribute)
	return attribute.name .. '_'
end
local function get_attribute_name(attribute, index)
	if attribute.count == 1 then
		return attribute.name
	end
	return get_attribute_name_raw(attribute) .. ("xyzw"):sub(index, index)
end

local position_attr = get_attribute_name_raw(POSITION_ATTRIBUTE)


local function get_lines(lines)
	local result = {}
	for i=1,#lines do
		local line = lines[i]
		if type(line) == 'table' then
			if line[2] then
				result[#result + 1] = line[1]
			end
		else
			result[#result + 1] = line
		end
	end

	return table.concat(result, '\n')
end

local function textindent(text, tabs)
	local lines = {}
	for s in string.gmatch(text .. "\n", "(.-)\n") do
		table.insert(lines, s)
	end
	local pad = ''
	for i=1,tabs do
		pad = pad .. '\t'
	end
	return pad .. table.concat(lines, '\n' .. pad):gsub('\n[\t]+\n', '\n\n')
end

local function if_greater(variables, gt, callback, indent)
	indent = indent or 1
	local function internal(state, index)
		if index <= #variables then
			state[index] = true
			local a = internal(state, index + 1)
			state[index] = false
			local b = internal(state, index + 1)
			if a ~= '' then
				local result = 'if ' .. variables[index] .. ' > ' .. gt .. ' then\n' .. textindent(a, indent)
				if b ~= '' then
					result = result .. '\nelse\n' .. textindent(b, indent)
				end
				return result .. '\nend'
			elseif b ~= '' then
				return 'if ' .. variables[index] .. ' <= ' .. gt .. ' then\n' .. textindent(b, indent) .. '\nend'
			end
			return ''
		else
			return callback(state)
		end
	end
	local state = {}
	for i = 1, #variables do
		state[i] = false
	end
	return internal(state, 1)
end

local function if_sorted(variables, callback, indent)
	indent = indent or 1
	local function permgen(a, n, states)
		if n == 0 then
			local clone = {}
			for i,v in pairs(a) do
				clone[i] = v
			end
			states[#states + 1] = clone
		else
			for i = 1, n, 1 do
				a[n], a[i] = a[i], a[n]
				permgen(a, n - 1, states)
				a[n], a[i] = a[i], a[n]
			end
		end
	end
	local function internal(matrix, perms)
		if #perms == 0 then
			return ''
		elseif #perms == 1 then
			local state = {}
			for i, v in pairs(perms[1]) do
				state[v] = i
			end
			return callback(state)
		end

		-- Get option with most items
		local a_elm = matrix[1]
		local a_idx = 1
		for i=2,#variables do
			local match = matrix[i]
			if a_elm.count < match.count then
				a_elm = match
				a_idx = i
			end
		end

		local b_idx = nil
		for i=1,#variables do
			if a_elm[i] then
				b_idx = i
				break
			end
		end
		
		local s_t = {}
		local s_f = {}
		for _, v in pairs(perms) do
			if v[a_idx] < v[b_idx] then
				s_t[#s_t + 1] = v
			else
				s_f[#s_f + 1] = v
			end
		end
		
		matrix[a_idx][b_idx] = nil
		matrix[a_idx].count = matrix[a_idx].count - 1

		local a = internal(matrix, s_t)
		local b = internal(matrix, s_f)

		matrix[a_idx][b_idx] = true
		matrix[a_idx].count = matrix[a_idx].count + 1

		if a ~= '' then
			if b ~= '' then
				return 'if ' .. variables[a_idx] .. ' >= ' .. variables[b_idx] .. ' then\n' .. textindent(a, indent) .. '\nelse\n' .. textindent(b, indent) .. '\nend' 
			end
			return a
		elseif b ~= '' then
			return b
		end

		return ''
	end

	local matrix = {}
	local a = {}
	for i=1,#variables do
		matrix[i] = {}
		matrix[i].count = #variables - i
		a[i] = i
		for j=i+1,#variables do
			matrix[i][j] = true
		end
	end

	local states = {}
	permgen(a, #variables, states)

	local perms = {}
	for i=1,#states do
		perms[i] = {}
		for j,v in pairs(states[i]) do
			perms[i][v] = j
		end
	end 

	return internal(matrix, perms)
end

-- TODO: Find how to split the trinagles in such a case we always have them sorted
local function triangleCases(state)
	local function delta(t, use_a, use_b, use_c)
		local pattern = '({t}{1} - {t}{{v}}) * m{1}{{v}} + {t}{{v}}'
		local result =
			(use_a ~= nil and pattern:gsub('{v}', use_a) or '{t}{1}') .. ', ' ..
			(use_b ~= nil and pattern:gsub('{v}', use_b) or '{t}{2}') .. ', ' ..
			(use_c ~= nil and pattern:gsub('{v}', use_c) or '{t}{3}')
		return result:gsub('{t}', t)
	end

	local function delta_z(t, use_a, use_b, use_c)
		local result =
			(use_a ~= nil and 'near' or '{t}{1}') .. ', ' ..
			(use_b ~= nil and 'near' or '{t}{2}') .. ', ' ..
			(use_c ~= nil and 'near' or '{t}{3}')
		return result:gsub('{t}', t)
	end

	local function get_variables(a, b, c)
		local lines = {}
		for _,v in pairs(VERTEX_ATTRIBUTES) do
			lines[#lines + 1] = '-- ' .. v.name
			if v.position then
				for index=1,v.count do
					local element = get_attribute_name(v, index)

					if index == 3 then
						lines[#lines + 1] = ', ' .. delta_z(element, a, b, c)
					else
						lines[#lines + 1] = ', ' .. delta(element, a, b, c)
					end
				end
			else
				for index=1,v.count do
					local element = get_attribute_name(v, index)
					lines[#lines + 1] = ', ' .. delta(element, a, b, c)
				end
			end
		end
		for _,v in pairs(FACE_ATTRIBUTES) do
			lines[#lines + 1] = '-- ' .. v.name
			for index=1,v.count do
				local element = get_attribute_name(v, index)
				lines[#lines + 1] = ', ' .. element
			end
		end

		return get_lines(lines):gsub('^(.-),( .*)', '%1 %2')
	end

	local inside = 0
	local i_idx = 0
	local o_idx = 0
	local desc = ''
	for i, v in ipairs(state) do
		if i > 1 then
			desc = desc .. ' '
		end
		desc = desc .. (v and i or '.')
		inside = inside + (v and 1 or 0)
		if v then
			i_idx = i
		else
			o_idx = i
		end
	end
	
	if inside == 0 then
		return ''
	end

	local s_idx = 1
	local out = ''
	if inside == 1 then
		out = get_lines({
			'-- ' .. desc,
			'local m{1}{2} = (near - {p}z{2}) / ({p}z{1} - {p}z{2})',
			'local m{1}{3} = (near - {p}z{3}) / ({p}z{1} - {p}z{3})',
			'renderTriangle(', textindent(get_variables(nil, 2, 3), 1), ')'
		})
		s_idx = i_idx
	elseif inside == 2 then
		out = get_lines({
			'-- ' .. desc,
			'local m{1}{2} = (near - {p}z{2}) / ({p}z{1} - {p}z{2})',
			'local m{1}{3} = (near - {p}z{3}) / ({p}z{1} - {p}z{3})',
			'renderTriangle(', textindent(get_variables(2, nil, nil), 1), ')',
			'renderTriangle(', textindent(get_variables(3, 2, nil), 1), ')'
		})
		s_idx = o_idx
	else
		out = get_lines({
			'-- ' .. desc,
			'renderTriangle(', textindent(get_variables(nil, nil, nil), 1), ')'
		})
	end

	return out:gsub('{1}', tostring(s_idx))
			  :gsub('{2}', tostring(1 + (s_idx + 0) % 3))
			  :gsub('{3}', tostring(1 + (s_idx + 1) % 3))
			  :gsub('{p}', position_attr)
end

local function get_parameters_sort()
	local lines = {}
	for _,v in pairs(VERTEX_ATTRIBUTES) do
		lines[#lines + 1] = '-- ' .. v.name
		for index=1,v.count do
			local element = get_attribute_name(v, index)
			lines[#lines + 1] = ', ' .. element .. '{1}, ' .. element .. '{2}, ' .. element .. '{3}'
		end
	end
	for _,v in pairs(FACE_ATTRIBUTES) do
		lines[#lines + 1] = '-- ' .. v.name
		for index=1,v.count do
			local element = get_attribute_name(v, index)
			lines[#lines + 1] = ', ' .. element
		end
	end
	return table.concat(lines, '\n'):gsub('^(.-),( .*)', '%1 %2')
end

local function get_parameters()
	return get_parameters_sort()
		:gsub('{1}', '1')
		:gsub('{2}', '2')
		:gsub('{3}', '3')
end
%}

-- https://learn.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules#triangle-rasterization-rules-without-multisampling
local _math_clamp = function(x, min, max)
	if x < min then return min end
	if x > max then return max end
	return x
end
local _math_floor = math.floor
local _math_ceil  = math.ceil
local _math_max   = math.max
local _math_min   = math.min

local function renderTriangleInternal(
	y_min, y_mid, y_max,
	x_min, x_mid, x_max,
	x_sta, x_end,

{! textindent(get_parameters(), 1) !}
)
{#full_function#}
	TRIANGLES = TRIANGLES + 1
{%
	-- Apply perspective correction on vertex attributes
	if POSITION_ATTRIBUTE.count > 2 and #VERTEX_ATTRIBUTES > 1 then
		for i=1,3 do
			@insert('\t' .. position_attr .. 'z' .. i .. ' = 1 / ' .. position_attr .. 'z' .. i .. '\n')
		end
		
		for _, v in pairs(VERTEX_ATTRIBUTES) do
			if not v.position then
				@insert('\t-- ' .. v.name .. '\n')
				for i=1,3 do
					for index=1,v.count do
						local element = get_attribute_name(v, index)
						@insert('\t' .. element .. i .. ' = ' .. element .. i .. ' * ' .. position_attr .. 'z' .. i .. '\n')
					end
				end
			end
			@insert('\n')
		end
	end
%}
{% if USE_DEPTH or USE_COLOR or USE_UV then %}
	-- Barycentric calculations
	local cyx = x_max - x_min
	local cyy = y_max - y_min
	local czx = x_mid - x_min
	local czy = y_mid - y_min
	local det = 1 / (czx * cyy - cyx * czy)
{% end %}
{% if USE_UV then %}
	local tw = TEXTURE and TEXTURE.w
	local th = TEXTURE and TEXTURE.h
	local td = TEXTURE and TEXTURE.data
{% end %}
	local y_d0 = y_mid - y_max
	local y_d1 = y_min - y_mid

	-- y_d0 = y_mid - y_max
	if y_d0 > 0 then -- TOP TRIANGLE, FLAT BOTTOM
		local x13_s = (x_sta - x_max) / y_d0
		local x23_s = (x_end - x_max) / y_d0
		local dy0 = _math_ceil(y_max - 0.5)
		local dy1 = dy0 + (0.5 - y_max)

		y_d0     = _math_min(y_d0 - dy1, H - dy0)
		local ys = _math_max(0         , 1 - dy0)
		for yy=ys,y_d0 do
			local xs = (yy + dy1) * x13_s + x_max
			local xe = (yy + dy1) * x23_s + x_max
			local yb = yy + dy0

{#triangle#}
			local PIXELS_Y = PIXELS[yb]
{% if USE_DEPTH then %}
			local DEPTHS_Y = DEPTHS[yb]
{% end %}

{% if USE_DEPTH or USE_COLOR or USE_UV then %}
			local yyy = yb - y_min + 0.5
{% end %}
			xs = _math_max(xs, 1)
			xe = _math_min(xe, W)
			xs = _math_ceil(xs - 0.5)
			xe = _math_ceil(xe - 0.5) - 1

			for xx=xs,xe do
{% if USE_DEPTH or USE_COLOR or USE_UV then %}
				local xxx = xx - x_min + 0.5
				local c_y = (xxx * cyy - yyy * cyx) * det
				local c_z = (yyy * czx - xxx * czy) * det
				local c_x = 1.0 - c_y - c_z

				local depth = 1 / ({!position_attr!}z1 * c_x + {!position_attr!}z2 * c_y + {!position_attr!}z3 * c_z)
{% end %}
{% if USE_DEPTH then %}
				if DEPTHS_Y[xx] > depth then
					DEPTHS_Y[xx] = depth
{% end %}
					local cc = C
{% if USE_COLOR then %}
					local va_r = depth * (r1 * c_x + r2 * c_y + r3 * c_z)
					local va_g = depth * (g1 * c_x + g2 * c_y + g3 * c_z)
					local va_b = depth * (b1 * c_x + b2 * c_y + b3 * c_z)

					va_r = _math_floor(_math_clamp(va_r * 6, 0, 5.999))
					va_g = _math_floor(_math_clamp(va_g * 6, 0, 5.999))
					va_b = _math_floor(_math_clamp(va_b * 6, 0, 5.999))
					cc = va_r + (va_g * 6) + (va_b * 36)
{% end %}
{% if USE_UV then %}
					if TEXTURE ~= nil then
						local xc = depth * (u1 * c_x + u2 * c_y + u3 * c_z)
						local yc = depth * (v1 * c_x + v2 * c_y + v3 * c_z)
						xc = _math_clamp(_math_floor(xc * tw), 0, tw - 1)
						yc = _math_clamp(_math_floor(yc * th), 0, th - 1)
						cc = td[xc + yc * tw + 1]
					end
{% end %}
					PIXELS_Y[xx] = cc
					RASTERED = RASTERED + 1
{% if USE_DEPTH then %}
				end
{% end %}
			end
{#triangle#}
		end
	end

	-- y_d1 = y_min - y_mid
	if y_d1 > 0 then -- BOTTOM TRIANGLE, FLAT TOP
		local x13_s = (x_min - x_sta) / y_d1
		local x23_s = (x_min - x_end) / y_d1
		local dy0 = _math_ceil(y_mid - 0.5)
		local dy1 = dy0 + (0.5 - y_mid)

		y_d1     = _math_min(y_d1 - dy1, H - dy0)
		local ys = _math_max(0         , 1 - dy0)
		for yy=ys,y_d1 do
			local xs = (yy + dy1) * x13_s + x_sta
			local xe = (yy + dy1) * x23_s + x_end
			local yb = yy + dy0

{#triangle#}
		end
	end
{#full_function#}
end

local function renderTriangle(
{! textindent(get_parameters(), 1) !}
)
	local A = W / 2.0
	local B = H / 2.0
	local sx1 = A + ({!position_attr!}x1 * H) / {!position_attr!}z1
	local sx2 = A + ({!position_attr!}x2 * H) / {!position_attr!}z2
	local sx3 = A + ({!position_attr!}x3 * H) / {!position_attr!}z3
	local sy1 = B + ({!position_attr!}y1 * H) / {!position_attr!}z1
	local sy2 = B + ({!position_attr!}y2 * H) / {!position_attr!}z2
	local sy3 = B + ({!position_attr!}y3 * H) / {!position_attr!}z3
{% if USE_FACE_CULL then %}
	if ((sx2 - sx1) * (sy3 - sy1) - (sx3 - sx1) * (sy2 - sy1)) < 0 then
		return
	end
{% end %}

{!
textindent(if_sorted({ 'sy1', 'sy2', 'sy3' }, function(state)
	local res = ''
	for i,v in pairs(state) do
		if i > 1 then
			res = res .. ','
		end
		res = res .. v
	end

	local out = get_lines({
		'local x_sta = ((sx{1} - sx{3}) / (sy{1} - sy{3})) * (sy{2} - sy{1}) + sx{1}',
		'local x_end = sx{2}',
		'if x_sta > x_end then',
		'	x_sta, x_end = x_end, x_sta',
		'end',
		--[[textindent(
			{#full_function#}
				:gsub('y_min', 'sy{1}')
				:gsub('y_mid', 'sy{2}')
				:gsub('y_max', 'sy{3}')

				:gsub('x_min', 'sx{1}')
				:gsub('x_mid', 'sx{2}')
				:gsub('x_max', 'sx{3}')

				-- TODO do for all vertex attributes
		, 0),]]
		'renderTriangleInternal(',
		'	sy{1}, sy{2}, sy{3},',
		'	sx{1}, sx{2}, sx{3},',
		'	x_sta, x_end,',
			textindent(get_parameters_sort(), 1),
		')'
	})

	out = out:gsub('{1}', tostring(state[1]))
			 :gsub('{2}', tostring(state[2]))
			 :gsub('{3}', tostring(state[3]))
	return '-- {' .. res .. '}\n' .. out
end), 1)
!}
end

function raster.renderTriangleCulling(geometry, near)
{%
	local face_size = 0
	for _, v in pairs(VERTEX_ATTRIBUTES) do
		face_size = face_size + v.count * 3
	end
	for _, v in pairs(FACE_ATTRIBUTES) do
		face_size = face_size + v.count
	end
%}
	for i=1,#geometry,{!face_size!} do
{%
		local idx = 0
		for _, v in pairs(VERTEX_ATTRIBUTES) do
			@insert('\t\t-- ' .. v.name .. '\n')
			for i=1,3 do
				for index=1,v.count do
					local element = get_attribute_name(v, index)
					local pattern = '\t\tlocal {t}{1} = geometry[i + ' .. (idx) .. ']\n'
					@insert(pattern:gsub('{t}', element):gsub('{1}', i))
					idx = idx + 1
				end
			end
			@insert('\n')
		end

		for _, v in pairs(FACE_ATTRIBUTES) do
			@insert('\t\t-- ' .. v.name .. '\n')
			for index=1,v.count do
				local element = get_attribute_name(v, index)
				@insert('\t\tlocal ' .. element .. ' = geometry[i + ' .. idx .. ']' .. '\n')
				idx = idx + 1
			end
			@insert('\n')
		end
%}
		-- print()
		-- print({!position_attr!}x1, {!position_attr!}x2, {!position_attr!}x3)
		-- print({!position_attr!}y1, {!position_attr!}y2, {!position_attr!}y3)
		-- print({!position_attr!}z1, {!position_attr!}z2, {!position_attr!}z3)
{!
		textindent(if_greater({ position_attr .. 'z1', position_attr .. 'z2', position_attr .. 'z3' }, 'near', triangleCases), 2)
!}
	end
end

local function rgb(r, g, b)
	r = _math_floor(_math_clamp(r * 6, 0, 6))
	g = _math_floor(_math_clamp(g * 6, 0, 6))
	b = _math_floor(_math_clamp(b * 6, 0, 6))
	return r + (g * 7) + (b * 42)
end

function raster.set_color(color)
	C = color
end

function raster.set_size(w, h)
	W = w
	H = h
end

function raster.set_texture(texture)
	TEXTURE = texture
end

function raster.get_rastered_info()
	local result = RASTERED
	local tris = TRIANGLES
	RASTERED = 0
	TRIANGLES = 0
	return result, tris
end

return raster
